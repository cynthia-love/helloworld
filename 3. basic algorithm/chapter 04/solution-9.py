# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    递归例子-二路递归

    调用路径为二叉树, 左和右合起来才能得到父节点的解

    有一个关键知识点要记住, 递归的空间复杂度
    = 单个递归函数的空间复杂度*递归调用深度(即递归调用栈的长度)
    即, 时间复杂度和递归调用次数有关, 空间复杂度和递归调用深度有关
"""

# 数组和, 先看之前的例子

s = [1, 2, 8, 100, -1, 3]

"""
    时间复杂度: n-1, n-2....0, 所以是O(n)
    空间复杂度: n个递归函数的活动记录存储, 所以是O(n)
"""
def f1(k):
    if k == 0 : return s[k]
    else: return s[k]+f1(k-1)

print(f1(len(s)-1))

"""
    sum(n) = 前一半和+后一半和
    
    时间复杂度: 以2的幂分析, 比如8
    f(1-8) = f(1-4)+f(5-8)
           = f(1-2)+f(3-4)+f(5-6)+f(7-8)
           = f(1)+f(2)+.....+f(8)
           
    = n+n/2+n/4+...+1, 一共log(n)项
    = n*(1-1/2^log(n))/(1/2) = 2*n-n/n = 2*n-1 = O(n)
    
    空间复杂度: 空间复杂度=每次递归的空间复杂度*递归深度
    注意这里是递归深度而不是递归次数
    
    注意, 递归是深度优先而不是广度优先
    f(1-8) = f(1-4)+f(5-8)
    实际执行过程并不是同步把f(1-4)和f(5-8)再展开到下一级
    而是把f(1-4)计算到底
    f(1-4) = f(1-2)+...
           = f(1)+..., 最后一级直接返回
    f(1-4)计算完成后栈就清空了, 再给f(5-8)用
    所以需要的调用栈个数等于递归深度
    
    这里递归深度是log(n), 每次递归空间复杂度是O(1)
    所以总的空间复杂度是O(log(n))
"""
def f2(left, right):
    mid = (left + right) // 2
    if left == right: return s[mid]
    else:
        return f2(left, mid)+f2(mid+1, right)

print(f2(0, len(s)-1))

