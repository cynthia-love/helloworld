# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    分析如下算法的时间复杂度
    序列A, 长度为2的幂, 计算所有元素之和
    创建一个新的序列B, 其大小是A的一半
    且B[i] = A[2i]+A[2i+1]
    如果B的大小为1, 则输出B[0], 否则用B取代A, 重复此过程
    比如:

    0 1 2 3 4 5 6 7

    B[0] = A[0]+A[1]
    B[1] = A[2]+A[3]
    B[2] = A[4]+A[5]
    B[3] = A[6]+A[7]

    每次大小缩小一半, O(log(n))???

    不对, 每次递归的时间复杂度并不一样, 不能直接乘以次数

    n/2, n/4, n/8, ...1, 一共log(n)次, 加起来, 最终是O(n)

    空间复杂度, 是每次空间复杂度*深度, 这里深度和次数相等
    但空间复杂度面临同样的问题, 即每次递归的空间复杂度不一样

    所以这里也是要一个个加, 最终也是O(n)
"""
from helloutils.tracker import Track

@Track
def f(s: list):
    if len(s) == 1: return s[0]
    return f([s[2*i]+s[2*i+1] for i in range(len(s)//2)])

print(f([0, 1, 2, 3, 4, 5, 6, 7]))
