# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    递归算法的不足
"""

# 演示一个低效的唯一性判断函数
# 当然, 低效并不是因为用了递归, 而是递归设计的不好
"""
    基本思路
    f(n)唯一:
    1. 如果只有一个元素, 则唯一
    2. 如果左边n-1个不唯一则不唯一
    3. 如果右边n-1个不唯一则不唯一
    4. 否则, 即左n-1唯一, 右n-1唯一, 即中间n-2唯一, 且不含左右
    那么判断左!=右即唯一
    
    怎么估计时间复杂度呢?
    先判断递归调用次数
    第一级 1, 长度n-0
    第二级 1*2, 长度n-1
    第三级 1*2*2, 长度n-2
    ...最后一级, 长度为1, 即n-(n-1)
    1+2^1+2^2+...+2^(n-1) = 1*(1-2^n)/(1-2) = O(2^n)
    效率极低, 因为存在很多重复性工作, 比如左n-1和右n-1中间的n-2部分重复处理
    
"""

s = [1, 2, 3, 4, 5, 8, 100, 8]
def f1(left, right):
    if right-left <= 1: return True
    if not f1(left, right-1): return False
    if not f1(left+1, right): return False
    return s[left] != s[right]

print(f1(0, len(s)-1))

# 演示一个低效的计算斐波那契数列第n项函数(0开始)
"""
    分析:
    f(0)    1
    f(1)    1
    f(2)    2
    f(3)    3
    f(4)    5
    f(5)    8
    f(n) = f(n-1)+f(n-2) >= 2*f(n-2)
    即n的递归函数调用次数是n-2时的两倍以上, 时间复杂度随n以2指数级变大
    所以此算法为O(2^n)
"""
def f2(n):
    if n <= 1: return n
    return f2(n-1)+f2(n-2)

# 对f2()函数的优化
"""
    思路: f2的递归最大的问题是重复计算
    计算f(n)的时候要来一遍f(n-2), 计算f(n-1)的时候还得来一遍f(n-2)
    一种优化思路是合并递归函数, 由多路分治变成单路, 时间复杂度变成O(n)
    f(0) = 0
    f(1) = 1
    f(n) = f(n-1)+f(n-2)
    
    改成:
    f(1) = 1, 0
    f(n-1) = a, b
    f(n) = a+b, a = f(n-1)[0]+f(n-1)[1], f(n-1)[0]
    
    有点绕, 不过这种思维方式可以记一下, 可能某些场景能起到妙用
"""
def f3(n):
    if n <= 1: return n, 0
    a, b = f3(n-1)
    return a+b, a
print(f3(4)[0])

# 对f2()函数的第二种优化思路, 记住中间结果
d = {}

def f4(n):
    if n in d: return d[n]

    if n <= 1: res = n
    else: res = f4(n-1)+f4(n-2)
    d[n] = res
    return res

print(f4(5))
