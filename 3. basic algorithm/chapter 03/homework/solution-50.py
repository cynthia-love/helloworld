# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    多项式: p(x) = a0*x^0+a1*x^1+a2*x^2+...+an*x^n
    1. 设计一个算法, 时间复杂度为O(n^2)
    2. 优化到O(n*log(n))
    3. 第三种思路, 霍纳法
    p(x) = a0+x(a1+x(a2+....(an-1+an*x)))
    t(n):
    算到n-1, 2
    算到n-2, 一乘一加, +2
    算到n-3, 再+2
    ...到0, +2
    所以t(n)是O(n)的
"""

# 1. 看到n^2一般都想到双层循环

def f():
    x = 8
    a = [1, 2, 3, -1, 8, 2]
    res = 0

    for i in range(len(a)):
        res += a[i]*(x**i)  # 复杂度主要再x**i, 可以拆分成循环乘以x
    return res
    # 1+1+2+3+4+...+n, 所以是O(n^2)
print(f())

# 2. 看到log(n)一般会想到分治, 比如2^5 = 2^3*2^2
def f2():
    def rf(x, n):
        # 这里因为分治而不是减治, 两条路都得走, 会遇到重复的情况
        # 用动态规划的思想把中间结果存起来性能更好些, 尤其此例中
        # 不仅单次求会遇到重复内容, 外层还是循环, 重复的会更多
        if n == 0: return 1
        if n == 1: return x

        n1 = n // 2
        n2 = n - n // 2

        return rf(x, n1)*rf(x, n2)

    # 为了简化分析, 认为都是2的指数, 比如求2^64
    # 这样递推公式可以简化为: f(n) = f(n/2)*f(n/2)
    # 而时间复杂度公式则是: t(n) = 2*t(n/2)+1
    """
        证明t(n)是O(log(n))的
        当t == 1时, t(n) = 1 <= 10*log(n)
        假设当t = i时, t(n) <= 10*log(n)
        则当t = i*2时, t(n) = 2*t(i)+1 <= 20*log(n) + 1
        所以t(n)是O(log(n))的
    """

    x = 8
    a = [1, 2, 3, -1, 8, 2]
    res = 0

    # 与f1相比, 这里仅仅是内层循环求x^n部分的算法改了
    for i in range(len(a)):
        res += a[i]*rf(x, i)  # 复杂度主要再x**i, 可以拆分成循环乘以x
f2()

# 3. 霍纳法
def f3():
    x = 8
    a = [1, 2, 3, -1, 8, 2]
    res = a[-1]
    # 1+2*x+3*x^2-x^3+8*x^4+2*x^5
    # = 1+x*(2+3*x^1-x^2+8*x^3+2*x^4)
    # = 1+x*(2+x*(3-x+8*x^2+2*x^3))
    # = 1+x*(2+x*(3+x*(-1+8*x+2*x^2)))
    # = 1+x*(2+x*(3+x*(-1+x*(8+2x))))
    # = 1+x*(2+x*(3+x*(-1+x*(8+x*2))))

    for i in range(len(a)-2, -1, -1):
        res = a[i]+x*res

    return res

print(f3())


