# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    数学方法
    为了避免实验方法的三个缺点, 一般直接采用数学分析方法
    (三个缺点: 软硬件环境控制/无法考虑所有可能输入/算法必须先实现)
"""
"""
    首先, 要定义原子操作, 原子操作即一个执行时间为常数的低级别指令
    这个方法隐含假设为, 不同原子操作的运行时间非常接近, 所以可以用原子操作
    的数量直接代表时间复杂度, 常见原子操作有:
    1. 赋值, 即给对象指定标识符, x = 1
    2. 根据标识符获取对象, print(x)
    3. 执行算数运算, x += 1
    4. 比较, x > 1
    5. 索引, l[0]
    6. 调用函数, f()
    7. 从函数返回
"""

"""
    在相同数量级输入的情况下, 运行速度也是会有不同的
    比如从[1, 2, 3, 4, 5]中查找值, 查找1和5运行速度不一样
    理想情况下, 应该求各种情况下的平均值, 但是这里需要获取
    输入的概率分布, 即多大概率输入是1, 2, 3, 4, 5, 其它
    然后把各种输入下的时间复杂度加权平均
    
    为了简化分析, 一般采用最坏情况下的复杂度分析
    比如[1, 2, 3, 4, 5]一般计算输入为其它
    f(5) = 5, f(6) = 6
    f(n) = O(n)
"""

# 算法分析中常用的7种函数
"""
    1. 常数函数
    f(n) = c, O(1)
"""
"""
    2. 对数函数
    f(n) = logb(n), 即b^f(n) = n
    在算法分析中, 一般底数为2(而不是数学中的10)时会把底数省略
    即log(n)的底数为2
    f(8) = log(8) = 3
    
    实际计算时一般用上界近似值, 比如log(12) 上界为4
    12/2/2/2/2 = 0.75, 第一个小于1的值, 所以上界为4
    
    典型的比如二分查找[1, 2, 3, 4, 5, 6], 不停地除以2
    时间复杂度就是典型的O(log(n))
    6, 3, 1
    6/2/2/2 = 0.75, 上界为3
"""
