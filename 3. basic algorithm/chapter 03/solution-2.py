# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    数学方法
    常见的7种函数
"""
"""
    首先, 要定义原子操作, 原子操作即一个执行时间为常数的低级别指令
    这个方法隐含假设为, 不同原子操作的运行时间非常接近, 所以可以用原子操作
    的数量直接代表时间复杂度, 常见原子操作有:
    1. 赋值, 即给对象指定标识符, x = 1
    2. 根据标识符获取对象, print(x)
    3. 执行算数运算, x += 1
    4. 比较, x > 1
    5. 索引, l[0]
    6. 调用函数, f()
    7. 从函数返回
"""

"""
    在相同数量级输入的情况下, 运行速度也是会有不同的
    比如从[1, 2, 3, 4, 5]中查找值, 查找1和5运行速度不一样
    理想情况下, 应该求各种情况下的平均值, 但是这里需要获取
    输入的概率分布, 即多大概率输入是1, 2, 3, 4, 5, 其它
    然后把各种输入下的时间复杂度加权平均
    
    为了简化分析, 一般采用最坏情况下的复杂度分析
    比如[1, 2, 3, 4, 5]一般计算输入为其它
    f(5) = 5, f(6) = 6
    f(n) = O(n)
"""

# 算法分析中常用的7种函数
"""
    1. 常数函数
    f(n) = c, O(1)
"""
"""
    2. 对数函数
    f(n) = logb(n), 即b^f(n) = n
    在算法分析中, 一般底数为2(而不是数学中的10)时会把底数省略
    即log(n)的底数为2
    f(8) = log(8) = 3
    
    实际计算时一般用上界近似值, 比如log(12) 上界为4
    12/2/2/2/2 = 0.75, 第一个小于1的值, 所以上界为4
    
    典型的比如二分查找[1, 2, 3, 4, 5, 6], 不停地除以2
    时间复杂度就是典型的O(log(n))
    6, 3, 1
    6/2/2/2 = 0.75, 上界为3 (这里是向上取整, 有时候还会向下取整, 即2)
    
    对数规则:
    logb(a*c) = logb(a) + logb(c)
    logb(a/c) = logb(a) - logb(c)
    logb(a^c) = c*logb(a)
    logb(a) = logd(a)/logd(b) = ln(a) / ln(b)
    b^(logd(a)) = a^(logd(b))
    
    以底数2为例:
    log(ab) = log(a) + log(b)
    log(a/b) = log(a) - log(b)
    log(a^c) = c*log(a)
    log(a) = ln(a)/ln(2)
    2^(ln(a)) = a^(ln(2))
    
    log(2n) = log(2) + log(n) = 1 + log(n)
    log(n/2) = log(n) - log(2) = log(n) - 1
    log(n^3) = 3*log(n)  (这里要注意, log(n), log(n^2), log(n^3)是一个数量级, 都是log(n)
    log(2^n) = n
    log4(n) = log(n) / log(4) = log(n) / 2
    2^(log(n)) = n
    
    特别需要强调的俩性质是:
    log(n^2) = 2*log(n), 同一数量级
    log(n) = ln(n) / ln(2), 因为计算器上没有log2(x), 可以用这个公式去算log2(n)
    
"""

"""
    3. 线性函数
    f(n) = n
    比如判断[1, 2, 3, ..n]的每一个元素是否大于0
"""

"""
    4. nlog(n)函数
    f(n) = n*log(n)
    1 < log(n) < n
    所以 n < n*log(n) < n^2
    
    log(n) < n < n*log(n) < n^2, 记住这个式子, 别连哪个大哪个小都分不清还谈什么时间复杂度分析
    
    时间复杂度为n*log(n)的比如归并排序
"""

"""
    5. n^2函数
    f(n) = n^2
    
    比如:
    [1, 2, 3, 4, 5], 双层循环, 外层n, 内层n, 则总的时间复杂度n+n+n+n... = n*n = n^2
    
    除了这种情况, 还有一种常见的, 内层每次循环数不一样, 比如:
    5, 4, 3, 2, 1, 即n, n-1, n-2, n-3....1, 加总为: 1/2*n(n+1), 时间复杂度也是O(n^2)
"""

"""
    6. n^3与多项式
    f(n) = n^3
    f(n) = a0+a1*n^1+a2*n^2+...+ad*n^d = ∑ai*n^i, i: 0~d
    
"""

"""
    7. b^n, 指数函数, b称为底
    f(n) = b^n
    
    性质:
    (b^a)^c = b^(a*c)
    b^a*b^c = b^(a+c)
    b^a/b^c = b^(a-c)
    
    指数可以是小数和负数
    2^1/2 = 根号下2
    2^-2 = 1/(2^2) = 1/4 = 2^(0-2) = 2^0/2^2
    
    等比数列求和:
    x1+x1*a+x1*a*a+...+x1*a^(n-1)
    
    S = x1*(1-a^n)/(1-a)
    
    比如: 1+2+4+8+..+2^(n-1) = 1*(1-2^n)/(1-2) = 2^n-1, 即使用n位可以表示的最大整数
"""

"""
    7种常用函数的复杂度比较
    1 < log(n) < n < n*log(n) < n^2 < n^3 < 2^n
    注意这里的log(n)底数为2而不是计算器上的10
    
    再补充俩概念:
    向下取整: 小于或等于x的最大整数
    向上取整: 大于或等于x的最小整数
    
    2.5向下取整是2, 向上取整是3
"""

"""
    渐进分析
    
    虽然我们能确定一个算法的精确时间, 但没必要, 当输入规模无限增加, 求其极限
    
    比如 f(n) = n^2 + 2*n
    当n无限大时, n^2+2*n ~ n^2, 即n无限大时, f(n)渐进等价n^2
    
"""

"""
    

"""