# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    实现remove_all(list, value)函数, 要求最坏运行时间为O(n)
"""

"""
    分析, 思路1, 重复调用remove直到没目标值
    最坏情况下全是目标值, n+n-2+n-2+...+1, 时间复杂度O(n^2), 不满足要求
    
    思路2, 一次遍历, 双指针, 左指针指向空位, 右指针往右找第一个不是目标值的值
    
    思路3, 累积target的个数, 作为左移位数的依据
"""

# 思路2, 双指针, 左指针指向待插入空位
def f(l, target):

    """
    1234453336
      ↑↑
    1244453336
       ↑↑
    """
    p = -1

    for i in range(len(l)):

        # 是3, p如果是初始值, 设p为i位置, p不是初始值, 跳过
        if l[i] == target:
            if p == -1:
                p = i
        else:
            # 不是3, p如果是初始值, 跳过; 不是, 说明该位置可以放入元素, 放进去, p右移一位
            if p != -1:
                l[p] = l[i]
                p += 1

    print(l if p == -1 else l[:p])

f([1, 2, 3, 4, 4, 5, 3, 3, 3, 6], 3)

# 思路2的第二种方法, 左指针指向已调整好的部分, 更好理解些
def f2(l, target):

    p = -1

    for i in range(len(l)):

        # p始终指向已调整好的数组最后一个位置
        # 下一个如果不是3, 那么往p后面拼(当然可能存在重复赋值的情况)
        # 下一个如果是3, 直接跳过
        if l[i] != target:
            l[p+1] = l[i]
            p += 1

    print(l[:p+1])

f2([1, 2, 3, 4, 4, 5, 3, 3, 3, 6], 3)

# 思路3, 通过数目标值的个数确定当天元素位置
def f3(l, target):

    c = 0

    for i in range(len(l)):

        # 是目标值, 计数加1
        if l[i] == target:
            c += 1
        else:
            # 不是目标值, 向左找插入位置
            l[i-c] = l[i]

    print(l[:len(l)-c])

f3([1, 2, 3, 4, 4, 5, 3, 3, 3, 6], 3)






