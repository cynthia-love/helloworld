# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    动态数组的摊销分析

    两种思路, 资产摊销和成本摊销

    资产摊销是每次操作都多投入, 到特殊节点遇到额外操作去摊销这些投入
    负债摊销是特殊节点的额外操作入负债, 摊给接下来的连续k个普通节点
"""
import ctypes

class DArray:
    def __init__(self):
        self.max_size = 1  # 初始给个1吧, 总要往里存东西的
        self.cur_size = 0

        # self.max_size*ctypes.py_object得到<class '__main__.py_object_Array_n'>
        # 实例化之后, 得到一个长为n的引用数组, 数组元素为指向python对象的指针
        self.array = (self.max_size*ctypes.py_object)()

    def __len__(self):
        return self.cur_size

    def __getitem__(self, k):
        if not 0 <= k < self.cur_size:
            raise IndexError
        return self.array[k]

    def append(self, obj):
        if self.cur_size == self.max_size:
            self.resize()
        # 这里的写法才是真正的动态数组写法, 即对已分配空间直接赋值
        # 另外注意, 这里直接赋值obj, 而不是id(obj), 而又支持多数据类型
        # 说明<class '__main__.py_object_Array_n'>这一级给把地址-对象转换做了
        self.array[self.cur_size] = obj
        self.cur_size += 1

    def resize(self):
        self.max_size *= 2
        array_new = (self.max_size*ctypes.py_object)()
        for i in range(self.cur_size):
            array_new[i] = self.array[i]
        self.array = array_new

"""
    重点分析append, 假设初始空间0
    1. 插入第一个, 判断空间不足, 分配一个空间, 无复制, 插入, O(1), 更新大小, O(1)
    2. 插入第二个, 判断空间不足, 分配两个空间, 复制, O(1), 插入, O(1), 更新大小, O(1)
    3. 插入第三个, 判断空间不足, 分配四个空间, 复制, O(2), 插入, O(1), 更新大小, O(1)
    4. 插入第四个, 判断空间足, 插入, O(1), 更新大小, O(1)
    5. 插入第五个, 判断空间不足, 分配8个空间, 复制, O(4), 插入, O(1), 更新大小, O(1)
    ...
    
    综上, 单个插入操作分两种情况
    1. 当前空间足, 即不是第2^i+1个, 直接插入, O(1)
    2. 当前空间不足, 即是第2^i+1个, 则主要时间花费在原数组复制上, O(k)
    
    分析单次不好分析, 分析连续插入n次, 再将结果除以n
    命题: 设S是一个有初始为空的动态数组, 扩展策略为乘以2, 则对S连续执行n次增添操作
    的运行时间为O(n)
    
    证明, 思路1, 资产摊销
    这个不是很好理解, 需要自己去假设, 先不考虑cur_size更新, 
    假设每次插入作价3个时间复杂度, 即假设n次插入为O(3n), 每次插入时间复杂度为3
    
    资产摊销的意思是:
    比如插入第3个, 此时空间大小是4, 时间复杂度应该是O(1), 多收了2
    插入第4个, 同样, 时间复杂度为O(1), 多收了2
    插入第5个, 此时需要将空间扩展到8, 然后把前四个值复制了, 再插入第5个
    其中, 前4个复制的开销用插入3和4时多收的2*2覆盖, 剩下的插入作价3, 多收了2
    继续6, 7, 8, 一共多收了4*2
    到第9个, 需要将空间扩展到16, 然后把前8个值复制了, 这个开销用5-8多收的钱覆盖
    
    综上, O(3n)的假设是对的, 即n次插入O(3n), 单次O(3)->O(1)
    
    思路2, 负债摊销, 比上面的好理解, 毕竟生想一个3硬币不好想
    比如插入第3个时, 空间满了, 此时的开销是: O(2)+O(1), 复制的O(2)让3和4各摊1
    插入第5个时, 空间满了, 此时开销是: O(4)+O(1), 复制的O(4)让5, 6, 7, 8摊销
    平均下来, 每次插入需要的开销: 摊销上一次2^i位置复制的开销1和自己的插入1, 共计O(2)
    
    3, 待摊O(2), 3-4
    5, 待摊O(4), 5-6-7-8
    9, 待摊O(8), 9-10-11-12-13-14-15
    即每次插入要负担自己的单次插入成本和上一次内存扩展的成本, 共计O(2)
    
"""

"""
    证明不仅仅是乘以2, 以任意几何级数扩大, 每次操作的摊销运行时间仍为O(1)
    
    分析:
    比如乘以1.5
    
    假设长度为k+1时分配变成1.5k
    
    k, k+1, k+2, ...1.5k, 1.5k+1...
    
    同样, k+1位置的复制成本O(k)要由接下来的0.5k次插入摊销, 每次摊销O(2)
    
    假设任意级数, ck
    则每次摊销: k/(c-1)k = 1/(c-1) = O(1), 怎么都是常数级的
"""

"""
    如果是采用固定增量呢, 即每次增加时不是乘以c, 而是+c
    
    假设长度为k+11时, 分配变成k+c
    
    k, k+1, k+2, ..., k+c, k+c+1
    
    那么, k+1位置的赋值成本要由接下来的c次插入摊销, 每次摊销O(k/c)
    算上插入, 每次操作成本: O(k/c)+O(1) = O(k)
    
    那么有结论:
    
    对初始为空的动态数组执行连续n次增添操作, 若每次数组满以后都按固定大小扩展,
    那么平均每次操作摊销时间复杂度O(n), n次插入就是O(n^2)
"""

"""
    空间复杂度呢? 按比例增加, 比如2
    1   1
    2   1+2
    3   1+2+4
    4   1+2+4
    5   1+2+4+8
    6, 7, 8 1+2+4+8
    9   1+2+4+8+16
    
    当存k个元素时, 假设2^i < k <= 2^(i+1)
    那么总耗用空间 = 2^0+2^1+...+2^(i+1)
    
    = 1*(1-2^(i+2))/(1-2)
    = 4*2^i-1
    
    i = log(k)
    
    = 4*k-1
    
    即存k个元素, 算上各种重新分配的, 大概是O(4k)的空间, 即:
    
    按几何增长的动态数组存储n个数的空间复杂度, 包括期间发生的重新分配浪费的
    为O(4n), 也是O(n)量级的!!!
    
    如果用摊销的思想呢
    1   1
    2   2
    3   4
    4   4
    5, 6, 7 8   8
    9, 10, 11, 12, 13, 14, 15   16
    
    假设k为2^i+1, 此时需要新分配一个k*2大小的空间, 且把原k大小的空间丢掉
    然后k从2^i+1到2*2^i, 去摊销额外多的: k+k大小, 即2k
    平均每个元素摊销3k
    (好像负债摊销(向后)和资产摊销(向前)得出的结果并不完全一致)
"""