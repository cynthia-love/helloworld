# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    python序列类型的效率-list和tuple
    tuple不用单独考虑, 其可以理解为不支持修改的list
    当然, 由于不支持修改, 其不用创建多余空间, 从而内存利用率更高
"""

l1 = [1, 2, 3, 4, 5]

"""
    不修改列表的操作
"""

"""O(1)"""
print(len(l1))  # O(1), 注意底层数组空间是大于实际元素个数的, 所以list单独存储了当前元素个数, 直接取
print(l1[3])  # O(1), l1指向第一个元素, 通过第一个元素的地址值直接计算第4个元素的地址值, 再去对应地址取值

"""O(n)"""
print(l1.count(3))  # 得全部遍历一遍才能数出来有几个目标值, 全遍历, 所以O(n)
print(l1.index(5))  # 最差情况要遍历到最后一个位置, 所以也是O(n)
print(5 in l1)  # 同样, 最差情况要遍历到最后一个位置, 所以也是O(n)

print([1, 2, 3, 4, 5] < [3])  # 注意数组比较是按字典顺序比较; 如果可比较部分都一样, 才比较长度, 显然, 时间复杂度依赖短的那个O(n短)

print(l1[1:3])  # 创建新的实例, 依赖于要赋多少值, 即要创建的新实例的长度O(n新)

print(l1+l1)  # 创建新的实例, 同样依赖要赋多少值, 即要创建的新实例的长度O(n1+n2)

print(l1*3)  # 创建新的实例, 同样依赖要赋多少值, 即要创建的新实例的长度O(c*n)


l2 = [1, 2, 3, 4, 5]
"""
    修改列表的操作
"""

"""O(1)"""
