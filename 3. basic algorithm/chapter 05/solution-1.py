# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    基于数组的序列
"""

"""
    python序列类型, 包括list, tuple, str
    共性:
    1. 支持数字下标访问元素
    2. 都使用array(数组)这种低层次概念表示
    
    计算机主存由位信息组成, 这些位通常根据系统架构归类为更大的单元
    比如每8位归为一个单元就称为一个字节
    每个字节定义了一个抽象的概念, 即存储地址
    比如相邻的两个字节地址分别为: #2150, #2151
    这里的相邻不仅是地址编号的相邻, 硬件上位置也是相邻的
    即根据存储地址可以快速唯一确定硬件上的位置
    从而对存储器上任一字节的存取时间复杂度都是O(1)
    不会说后面的取就比前面的慢
"""
"""
    数组, 这里的概念更偏向于方法
    即, 将一组相关变量一个接一个地存储在计算机存储器的一块连续区域内, 这样的表示法称为数组
    
    比如 s = 'SAMPLE', Unicode字符集
    那么'SAMPLE' 将被存储在连续12个字节里, 每两个字节构成一个单元
    数组的大小以单元计, 比如这里数组大小是6而不是12
    
    比如S所在地址 #2150, #2151; A所在地址 #2152, #2153
    
    这里s指向S, 即 #2150, 由于又知道每个单元占用大小, 所以可以计算
    s[0] 指向地址同s
    s[1] 指向地址 = s[0]+索引1*每个单元占用大小
                 = 2150+1*2 = 2152
    而正是由于数组要支持这种计算, 要求数组每个单元占用字节数必须相同
    
    这里要注意下面两者的区别: 
    s = 'SAMPLE'
    l = ['S', 'A', 'M', 'P', 'L', 'E']
    
"""

s = 'SAMPLE'
l = ['S', 'A', 'M', 'P', 'L', 'E']

print(s[1])
print(l[1])

"""
    这里输出都是A
    
    但是s只有一个指针, 内存里连续存储的是'SAMPLE', 然后s指向'S'所在的地址
    输出s[1]的时候, s[1]的地址是现算的, 算完直接取出该地址的值
    
    而l, 内存里连续存储的是 地址1, 地址2, 地址3..., 然后l指向地址1所在的地址
    输出l[1]的时候, 先算l[1]对应的地址, 然后从该处再取出一个地址值, 然后从
    这个再取出的地址的位置取出值
    
    即list比str实际上是多了一级
    这也是为什么list里的值能变, 变的并不是原数据内存位置的值, 而是指针指向
    
    
"""

print(id(l[1]))
l[1] = 8
print(id(l[1]))  # l[1]指向的地址变了

# s[1] = 'h', s[1]是的地址是根据s算出来的, 无法单独变更其方向指向