# -*- coding: utf-8 -*-
# Author: Cynthia

"""
    引用数组
    即list, set本质上是引用数组, 而非直接数组
    其连续存储的是指向元素对象的地址, 而非元素对象本身
    (对应的, str是直接数组, 数组元素就是值)

    另, 区别三个概念, 以l = [0, 1, 2, 3]为例
    1. 视图, 比如只看第2第3个元素, 那么第2个应该索引变成0; 不过python不像数据库, 没有视图概念
    2. 浅拷贝, l2 = l[1:3], 把l[1], l[2]的地址拷贝一份出来, 新数组元素指向原元素指向的对象
    3. 深拷贝, 把原元素指向的对象也造个新的出来, 新元素指针指向新对象

    常用的list*xxx, list截取, list.extend等都是浅拷贝, 改一个会影响其他元素的值!!!
    理解: [o]*3少用, 改为[C() for _ in range(3)]
"""
import copy

"""
    直接数组, 引用数组的简单对比
"""
s = 'helloworld'
l = ['helloworld', 'h', 'e', 'l']

# s, 直接数组, s[0]是利用s的地址计算出s[0]的地址, 然后直接去取出s[0]位置的值
# l, 引用数组, l[0]是利用l的地址计算出l[0]的地址, 然后取出l[0]位置的值, 但这个值是个地址, 然后再从这个地址指向的位置取出值


"""
    引用数组有些特殊的情况需要考虑
    一个数组的多个元素指向同一个对象
    以及多个数组的多个元素指向同一个对象
"""
class C:
    def __init__(self):
        self.e = 8
o = C()
oo = None
l1 = [1, 2, o, 3, o, oo, None]
print(l1[2], l1[4], id(l1[5]), id(l1[6]))
# <__main__.C object at 0x1032bc0d0> <__main__.C object at 0x1032bc0d0> 4345251944 4345251944
# 可以看出, 两个o实际上是同一个对象, 一改都改
# 另外, 这里还可以看出, None, 无论声明几次, 全局都保持一个对象实例

l2 = [1, 2, o, 3, o, oo, None]
print(l1[2], l2[2])
# <__main__.C object at 0x10b05d290> <__main__.C object at 0x10b05d290>
# 不同数组的元素指向同一个对象的例子, 同样, 一改都改

"""
    多个数组元素指向同一个对象(无论是是数组内部还是跨数组)可能带来的问题需要分两种情况讨论
    1. 指向的是不可变对象
    2. 指向的是可变对象
"""
x = 8
l3 = [x, x, 9, 100]
print(l3)
l3[0] = -1
print(l3)
# x是不可变对象, l3[0] = -1并没有改变x的值, 而是将l3[0]指向了一个新的位置

o = C()
l4 = [o, o, 8, 200]
l4[0].e = 888
print(l4[0].e, l4[1].e)
# o是可变对象, 注意可变也不是直接l4[x]=xxx这么改, 得在维持原指向的情况下改, 才能一改都改

"""
    浅拷贝与深拷贝
"""
l5 = copy.copy(l4)
print(l4[0], l5[0])  # 浅拷贝, 新数组里存的地址和老数组一样, 即指向同样的对象

l6 = copy.deepcopy(l4)
print(l4[0], l6[0], l6[1])
# <__main__.C object at 0x109b93310> <__main__.C object at 0x109badb10> <__main__.C object at 0x109badb10>
# 这里要注意一点, 对于数组内部多个元素指向同一个地址的情况, 深拷贝并不会破坏这种关系
# 比如这里的l4[0]和l4[1], 深拷贝的时候并不是无脑顺序遍历, 把l4[0]深拷贝一份, 再把l4[1]深拷贝一份
# 具体逻辑不清楚, 可以确定的是, 原l4的4个元素3个对象, l6拷贝出来也是4个元素3个对象, 而不是4个新对象

"""
    其他需要注意的常见操作
"""
# list*xxx
l7 = [0]*8
print(id(l7[0]), id(l7[1]))  # 4464997488 4464997488, 指向一样, 但是不可变元素, 不会有潜在不好影响
o = C()
l8 = [o]*3
print(l8[0], l8[1])
# <__main__.C object at 0x10e6deb50> <__main__.C object at 0x10e6deb50>
# 这种情况就需要注意了, list*xxx语法是浅拷贝!!!
# 有时候自定义类型, 初始化多个元素的时候要注意了, 不要用list*xxx语法, 得到的是多个数组元素指向同一个对象
l9 = [C() for _ in range(3)]
print(l9[0], l9[1])
# <__main__.C object at 0x10a4db250> <__main__.C object at 0x10a4f6bd0>
# 这么写才行

# 截取, append, extend
l10 = [1, 2, C(), 8]
l11 = l10[1:-1]
print(id(l10[1]), id(l11[0]))  # 4524463280 4524463280, 浅拷贝
print(id(l10[2]), id(l11[1]))  # 4455243088 4455243088, 浅拷贝
l11[0] = 100
print(l10)  # l11[0]改变指向不会影响l10[1]指向,说明确实是发生了拷贝, 虽然是浅的
o = C()
l10.append(o)
print(o, l10[-1])  # <__main__.C object at 0x1077b4d50> <__main__.C object at 0x1077b4d50>


l12 = [1, 2, C()]
l13 = [8, 9, C()]
l12.extend(l13)
print(l12, l13)  # 浅拷贝
print(id(l12[3]), id(l13[0]))  # 4363236720 4363236720, 浅拷贝
l13[0] = 100
print(l12)  # [1, 2, <__main__.C object at 0x10d155e90>, 8, 9, <__main__.C object at 0x10d155ed0>]
# 这里l13[0]改变指针值并不会影响l12[3], 说明确实是拷贝了的(虽然是浅), 而不是怀疑的直接拼接